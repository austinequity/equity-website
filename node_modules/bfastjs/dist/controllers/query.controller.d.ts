import { RulesController } from "./rules.controller";
import { DatabaseChangesController } from "./database.controller";
import { UpdateController } from "./update.controller";
import { HttpClientController } from "./http-client.controller";
import { AuthController } from "./auth.controller";
import { AggregateModel } from "../models/aggregate.model";
export declare enum QueryOrder {
    ASCENDING = 1,
    DESCENDING = -1
}
export declare class QueryController {
    private readonly domain;
    private readonly httpClientController;
    private readonly rulesController;
    private readonly authController;
    private readonly appName;
    private query;
    constructor(domain: string, httpClientController: HttpClientController, rulesController: RulesController, authController: AuthController, appName: string);
    byId(id: string): QueryController;
    count(countQuery?: boolean): QueryController;
    size(size: number): QueryController;
    skip(skip: number): QueryController;
    orderBy(field: string, order: QueryOrder): QueryController;
    equalTo(field: string, value: any): QueryController;
    hashes(localDataHashes: string[]): QueryController;
    notEqualTo(field: string, value: any): QueryController;
    greaterThan(field: string, value: any): QueryController;
    greaterThanOrEqual(field: string, value: any): QueryController;
    includesIn(field: string, value: any[]): QueryController;
    notIncludesIn(field: string, value: any[]): QueryController;
    lessThan(field: string, value: any): QueryController;
    lessThanOrEqual(field: string, value: any): QueryController;
    exists(field: string, value?: boolean): QueryController;
    searchByRegex(field: string, regex: string): QueryController;
    fullTextSearch(field: string, text: {
        search: string;
        language?: string;
        caseSensitive?: boolean;
        diacriticSensitive?: boolean;
    }): QueryController;
    raw(query: any): QueryController;
    private buildQuery;
    delete<T>(options?: RequestOptions): Promise<T>;
    updateBuilder(): UpdateController;
    changes(onConnect?: () => void, onDisconnect?: () => void, options?: RequestOptions): DatabaseChangesController;
    /**
     *
     * @param pipeline
     * @param options
     * @returns
     * @deprecated use bfast.database().table().aggregate()
     */
    aggregate<V = any>(pipeline: any[] | AggregateModel, options?: RequestOptions): Promise<V>;
    find<T>(options?: RequestOptions): Promise<T>;
    queryRuleRequest(queryRule: any): Promise<any>;
    aggregateRuleRequest(pipelineRule: any): Promise<any>;
}
export interface RequestOptions extends CacheOptions {
    useMasterKey?: boolean;
    returnFields?: string[];
}
export interface FileOptions extends RequestOptions {
    pn?: boolean;
    filename?: string;
}
interface CacheOptions {
    /**
     * enable cache in method level, override global option
     */
    cacheEnable?: boolean;
    /**
     * cache to expire flag
     */
    dtl?: number;
    /**
     * callback to response from network data, just before that data is updated to cache
     * @param identifier {string} cache identifier
     * @param data {T extend object} fresh data from network
     // * @deprecated use #onUpdated
     */
    freshDataCallback?: <T>(value: {
        identifier: string;
        data: T;
    }) => void;
}
export {};
